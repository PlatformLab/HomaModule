/* Copyright (c) 2020 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef TIMETRACE_H
#define TIMETRACE_H

#include <string>
#include <vector>

#include "test_utils.h"

// Change 1 -> 0 in the following line to disable time tracing globally.
#define ENABLE_TIME_TRACE 1

/**
 * class time_trace - Implements a circular buffer of entries, each of which
 * consists of a fine-grain timestamp, a short descriptive string, and
 * a few additional values. It's typically used to record times at
 * various points in an operation, in order to find performance bottlenecks.
 * It can record a trace relatively efficiently (< 10ns as of 7/2020),
 * and then either return the trace either as a string or print it to
 * the system log.
 *
 * This class is thread-safe. By default, trace information is recorded
 * separately for each thread in order to avoid synchronization and cache
 * consistency overheads; the thread-local traces are merged by when the
 * timetrace is printed, so the existence of multiple trace buffers is
 * normally invisible.
 *
 * The time_trace class should never be constructed; it offers only
 * static methods.
 *
 * If you want to use a single trace buffer rather than per-thread
 * buffers, see the subclass time_trace::buffer below.
 */
class time_trace {
    public:
	static void create_thread_buffer(std::string name);
	static void freeze();
	static std::string get_trace();
	static int print_to_file(const char *name);

	/** @frozen: nonzero means that the timetrace is already frozen. */
	static int frozen;
	
	class buffer;

	/**
	 * record() - Record an event in a thread-local buffer.
	 * @timestamp: The time at which the event occurred.
	 * @format:    A format string for snprintf that will be used, along
	 *             with arg0..arg3, to generate a human-readable message
	 *             describing what happened, when the time trace is printed.
	 *             The message is generated by calling snprintf as follows:
	 *             snprintf(buffer, size, format, arg0, arg1, arg2, arg3)
	 *             where format and arg0..arg3 are the corresponding
	 *             arguments to this method. This pointer is stored in the
	 *             time trace, so the caller must ensure that its contents
	 *             will not change over its lifetime in the trace.
	 * @arg0:      Argument to use when printing a message about this event.
	 * @arg1:      Argument to use when printing a message about this event.
	 * @arg2:      Argument to use when printing a message about this event.
	 * @arg3:      Argument to use when printing a message about this event.
	 */
	static inline void record(uint64_t timestamp, const char* format,
			uint32_t arg0 = 0, uint32_t arg1 = 0,
			uint32_t arg2 = 0, uint32_t arg3 = 0) {
#if ENABLE_TIME_TRACE
		thread_buffer->record(timestamp, format, arg0, arg1, arg2, arg3);
#endif
	}
	static inline void record(const char* format, uint32_t arg0 = 0,
			uint32_t arg1 = 0, uint32_t arg2 = 0, uint32_t arg3 = 0) {
#if ENABLE_TIME_TRACE
		record(rdtsc(), format, arg0, arg1, arg2, arg3);
#endif
	}

	static void reset();

    protected:
	time_trace();
	static void print_internal(std::string* s, FILE *f);

	/**
	 * @thread_buffer: points to a private per-thread time_trace::buffer;
	 * NULL means no such object has been created yet for the current thread.
	 */
	static __thread buffer* thread_buffer;

	/**
	 * @thread_buffers: holds pointers to all of the thread-private
	 * buffers created so far. Entries never get deleted from this object.
	 */
	static std::vector<buffer*> thread_buffers;

	/** struct event - Holds one entry in a time_trace::buffer. */
	struct event {
		/* See documentation for record method. */
		uint64_t timestamp;
		const char* format;
		uint32_t arg0;
		uint32_t arg1;
		uint32_t arg2;
		uint32_t arg3;
	};

    public:
	/**
	 * class buffer - Represents a sequence of events generated by a single
	 * thread.  Has a fixed capacity, so slots are re-used on a circular
	 * basis.  This class is not thread-safe.
	 */
	class buffer {
	    public:
		buffer(std::string name);
		~buffer();
		void record(uint64_t timestamp, const char* format,
				uint32_t arg0 = 0, uint32_t arg1 = 0,
				uint32_t arg2 = 0, uint32_t arg3 = 0);
		void reset();

	    protected:
		/** @name: name that identifies this buffer/thread. */
		std::string name;
		
		/**
		 * @BUFFER_SIZE_EXP: determines the number of events we can
		 * retain, as an exponent of 2.
		 */
		static const uint8_t BUFFER_SIZE_EXP = 16;

		/**
		 * @BUFFER_SIZE: total number of events that we can retain
		 * at any given time.
		 */
		static const uint32_t BUFFER_SIZE = 1 << BUFFER_SIZE_EXP;

		/**
		 * @BUFFER_MASK: bit mask used to implement a circular event buffer.
		 */
		static const uint32_t BUFFER_MASK = BUFFER_SIZE - 1;

		/**
		 * @next_index: index within events of the slot to use for the next
		 * call to record.
		 */
		int next_index;
		
		/**
		 * @events: Holds information from the most recent calls to record.
		 */
		time_trace::event events[BUFFER_SIZE];

		friend class time_trace;
	};
};

#define tt time_trace::record

#endif // TIMETRACE_H

