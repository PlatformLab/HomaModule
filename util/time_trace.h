/* Copyright (c) 2020-2022 Homa Developers
 * SPDX-License-Identifier: BSD-2-Clause or GPL-2.0+
 */

#ifndef TIMETRACE_H
#define TIMETRACE_H

#include <string>
#include <vector>

#include "test_utils.h"

// Change 1 -> 0 in the following line to disable time tracing globally.
#define ENABLE_TIME_TRACE 1

/**
 * class time_trace - Implements a circular buffer of entries, each of which
 * consists of a fine-grain timestamp, a short descriptive string, and
 * a few additional values. It's typically used to record times at
 * various points in an operation, in order to find performance bottlenecks.
 * It can record a trace relatively efficiently (< 10ns as of 7/2020),
 * and then either return the trace either as a string or print it to
 * the system log.
 *
 * This class is thread-safe. By default, trace information is recorded
 * separately for each thread in order to avoid synchronization and cache
 * consistency overheads; the thread-local traces are merged by when the
 * timetrace is printed, so the existence of multiple trace buffers is
 * normally invisible.
 *
 * The time_trace class should never be constructed; it offers only
 * static methods.
 *
 * If you want to use a single trace buffer rather than per-thread
 * buffers, see the subclass time_trace::buffer below.
 */
class time_trace {
    public:
	static void cleanup();
	static void freeze();
	static std::string get_trace();
	static int print_to_file(const char *name);

	/** @frozen: nonzero means that the timetrace is already frozen. */
	static int frozen;

    protected:
	class buffer;

	/**
	 * @tb: points to a private per-thread time_trace::buffer;
	 * NULL means no such object exists for the current thread.
	 */
	static __thread buffer* tb;

	/**
	 * @thread_buffers: holds pointers to all of the existing thread-private
	 * buffers. Entries get deleted only by free_unused.
	 */
	static std::vector<buffer*> thread_buffers;

    public:

	/**
	 * record() - Record an event in a thread-local buffer.
	 * @timestamp: The time at which the event occurred.
	 * @format:    A format string for snprintf that will be used, along
	 *             with arg0..arg3, to generate a human-readable message
	 *             describing what happened, when the time trace is printed.
	 *             The message is generated by calling snprintf as follows:
	 *             snprintf(buffer, size, format, arg0, arg1, arg2, arg3)
	 *             where format and arg0..arg3 are the corresponding
	 *             arguments to this method. This pointer is stored in the
	 *             time trace, so the caller must ensure that its contents
	 *             will not change over its lifetime in the trace.
	 * @arg0:      Argument to use when printing a message about this event.
	 * @arg1:      Argument to use when printing a message about this event.
	 * @arg2:      Argument to use when printing a message about this event.
	 * @arg3:      Argument to use when printing a message about this event.
	 */
	static inline void record(uint64_t timestamp, const char* format,
			uint32_t arg0 = 0, uint32_t arg1 = 0,
			uint32_t arg2 = 0, uint32_t arg3 = 0) {
#if ENABLE_TIME_TRACE
		tb->record(timestamp, format, arg0, arg1, arg2, arg3);
#endif
	}
	static inline void record(const char* format, uint32_t arg0 = 0,
			uint32_t arg1 = 0, uint32_t arg2 = 0, uint32_t arg3 = 0) {
#if ENABLE_TIME_TRACE
		record(rdtsc(), format, arg0, arg1, arg2, arg3);
#endif
	}

    protected:
	time_trace();
	static void print_internal(std::string* s, FILE *f);

	/** struct event - Holds one entry in a time_trace::buffer. */
	struct event {
		/* See documentation for record method. */
		uint64_t timestamp;
		const char* format;
		uint32_t arg0;
		uint32_t arg1;
		uint32_t arg2;
		uint32_t arg3;
	};

	/**
	 * class buffer - Represents a sequence of events generated by a single
	 * thread.  Has a fixed capacity, so slots are re-used on a circular
	 * basis.  This class is not thread-safe.
	 */
	class buffer {
	    public:
		buffer(std::string name);
		~buffer();
		void record(uint64_t timestamp, const char* format,
				uint32_t arg0 = 0, uint32_t arg1 = 0,
				uint32_t arg2 = 0, uint32_t arg3 = 0);
		void reset();

	    public:
		/** @name: name that identifies this buffer/thread. */
		std::string name;

		/**
		 * @BUFFER_SIZE_EXP: determines the number of events we can
		 * retain, as an exponent of 2.
		 */
		static const uint8_t BUFFER_SIZE_EXP = 16;

		/**
		 * @BUFFER_SIZE: total number of events that we can retain
		 * at any given time.
		 */
		static const uint32_t BUFFER_SIZE = 1 << BUFFER_SIZE_EXP;

		/**
		 * @BUFFER_MASK: bit mask used to implement a circular event buffer.
		 */
		static const uint32_t BUFFER_MASK = BUFFER_SIZE - 1;

		/**
		 * @next_index: index within events of the slot to use for the next
		 * call to record.
		 */
		int next_index;

		/**
		 * @ref_count: number of thread_buffer objects that reference
		 * this buffer. When this count becomes 0, the buffer can be
		 * deleted in the next call to time_trace::cleanup.
		 */
		int ref_count;

		/**
		 * @events: Holds information from the most recent calls to record.
		 */
		time_trace::event events[BUFFER_SIZE];

		friend class time_trace;
	};

    public:
	/**
	 * class thread_buffer - One of these should be instantiated as a
	 * local variable in the top-level function for each thread that
	 * invokes tt. Such a variable ensures that a buffer is available
	 * for the lifetime of that thread.
	 */
	class thread_buffer {
	    public:
		thread_buffer(std::string name);
		~thread_buffer();

	    protected:
		/* The buffer associated with this thread. Malloc-ed. The
		 * "official" reference to this is the one in thread_buffers.
		 */
		time_trace::buffer *buffer;
	};
};

#define tt time_trace::record

#endif // TIMETRACE_H

